package fr.asanokaze.openapihelper.navigation

import com.intellij.codeInsight.daemon.GutterIconNavigationHandler
import com.intellij.codeInsight.daemon.LineMarkerInfo
import com.intellij.codeInsight.daemon.LineMarkerProvider
import com.intellij.icons.AllIcons
import com.intellij.lang.javascript.psi.JSFunction
import com.intellij.lang.javascript.psi.ecmal4.JSClass
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.editor.markup.GutterIconRenderer
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.ui.popup.JBPopupFactory
import com.intellij.psi.PsiClass
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiMethod
import com.intellij.ui.ColoredListCellRenderer
import com.intellij.util.Function
import com.intellij.util.PsiNavigateUtil
import org.jetbrains.kotlin.idea.codeinsight.utils.findExistingEditor
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtNamedFunction
import javax.swing.Icon
import javax.swing.JList

/**
 * Simple wrapper for PsiElement to avoid direct use in popup model
 */
data class PsiElementWrapper(val element: PsiElement, val displayText: String)

/**
 * Line marker provider for OpenAPI Generator-generated Java/Kotlin/TypeScript code.
 *
 * This provider adds navigation markers to:
 * - Classes generated by OpenAPI Generator
 * - Methods with OpenAPI operation annotations
 * - TypeScript interfaces (model classes)
 * - TypeScript functions (operations)
 *
 * The provider uses the comment "OpenAPI Generator" as a hint to identify generated code.
 */
class GeneratedCodeLineMarkerProvider : LineMarkerProvider {

    private val LOG = Logger.getInstance(GeneratedCodeLineMarkerProvider::class.java)
    private val resolvers = SpecResolversFactory.resolvers()

    override fun getLineMarkerInfo(element: PsiElement): LineMarkerInfo<PsiElement>? {
        return when (element) {
            is PsiClass -> getLineMarkerForJavaClass(element)
            is KtClass -> getLineMarkerForKotlinClass(element)
            is PsiMethod -> getLineMarkerForJavaMethod(element)
            is KtNamedFunction -> getLineMarkerForKotlinMethod(element)
            is JSClass -> getLineMarkerForTypeScriptClass(element)
            is JSFunction -> getLineMarkerForTypeScriptFunction(element)
            else -> null
        }
    }

    private fun getLineMarkerForJavaClass(psiClass: PsiClass): LineMarkerInfo<PsiElement>? {
        if (!isOpenApiGeneratedClass(psiClass)) return null

        psiClass.nameIdentifier ?: return null
        return createLineMarker(psiClass, "Navigate to OpenAPI specification")
    }

    private fun getLineMarkerForKotlinClass(ktClass: KtClass): LineMarkerInfo<PsiElement>? {
        if (!isOpenApiGeneratedClass(ktClass)) return null

        ktClass.nameIdentifier ?: return null
        return createLineMarker(ktClass, "Navigate to OpenAPI specification")
    }

    private fun getLineMarkerForJavaMethod(psiMethod: PsiMethod): LineMarkerInfo<PsiElement>? {
        val containingClass = psiMethod.containingClass ?: return null
        if (!isOpenApiGeneratedClass(containingClass)) return null

        // Check if method has OpenAPI operation annotation or Spring mapping annotations
        // OR if it's in a delegate class (but not getRequest method)
        if (!hasOpenApiOperation(psiMethod) && !isValidDelegateMethod(psiMethod, containingClass)) return null

        psiMethod.nameIdentifier ?: return null
        return createLineMarker(psiMethod, "Navigate to OpenAPI operation")
    }

    private fun getLineMarkerForKotlinMethod(ktFunction: KtNamedFunction): LineMarkerInfo<PsiElement>? {
        // For Kotlin, we need to check the containing class by traversing the PSI tree
        var parent = ktFunction.parent
        while (parent != null && parent !is KtClass) {
            parent = parent.parent
        }
        val containingClass = parent ?: return null
        if (!isOpenApiGeneratedClass(containingClass)) return null

        // Check if method has OpenAPI operation annotation or Spring mapping annotations
        // OR if it's in a delegate class (but not getRequest method)
        if (!hasOpenApiOperation(ktFunction) && !isValidDelegateMethod(ktFunction, containingClass)) return null

        ktFunction.nameIdentifier ?: return null
        return createLineMarker(ktFunction, "Navigate to OpenAPI operation")
    }

    private fun getLineMarkerForTypeScriptClass(jsClass: JSClass): LineMarkerInfo<PsiElement>? {
        if (!isOpenApiGeneratedTypeScript(jsClass)) return null
        
        jsClass.nameIdentifier ?: return null
        return createLineMarker(jsClass, "Navigate to OpenAPI specification")
    }

    private fun getLineMarkerForTypeScriptFunction(jsFunction: JSFunction): LineMarkerInfo<PsiElement>? {
        if (!isOpenApiGeneratedTypeScript(jsFunction)) return null
        
        jsFunction.nameIdentifier ?: return null
        return createLineMarker(jsFunction, "Navigate to OpenAPI operation")
    }

    private fun createLineMarker(element: PsiElement, tooltip: String): LineMarkerInfo<PsiElement> {
        val icon: Icon = AllIcons.Gutter.ImplementingMethod
        val elt = when (element) {
            is PsiMethod -> element.nameIdentifier
            is KtNamedFunction -> element.nameIdentifier
            is PsiClass -> element.nameIdentifier
            is KtClass -> element.nameIdentifier
            is JSClass -> element.nameIdentifier
            is JSFunction -> element.nameIdentifier
            else -> {
                LOG.warn("Unsupported element type: ${element.javaClass}")
                null
            }
        } ?: element

        return LineMarkerInfo(
            elt,
            elt.textRange,
            icon,
            Function { tooltip },
            { _, _ -> navigateToOpenApiSpec(element) },
            GutterIconRenderer.Alignment.LEFT,
            { tooltip }
        )
    }

    private fun navigateToOpenApiSpec(element: PsiElement) {
        LOG.debug("Navigating to OpenAPI spec for element: ${element.javaClass.name}")

        val specElements = resolvers.flatMap { resolver ->
            try {
                resolver.resolveSpecElement(element.project, element)
            } catch (e: Exception) {
                LOG.warn("Resolver ${resolver.resolverName} failed for element $element", e)
                emptyList()
            }
        }

        if (specElements.isEmpty()) {
            LOG.debug("No OpenAPI spec elements found for $element")
            Messages.showInfoMessage(
                element.project,
                "No corresponding OpenAPI specification found for this element.",
                "OpenAPI Navigation"
            )
            return
        }

        val navigationHandler = GutterIconNavigationHandler<PsiElement> { _, _ ->
            if (specElements.size == 1) {
                PsiNavigateUtil.navigate(specElements.first())
            } else {
                // Create wrapper objects to avoid using PsiElement directly in popup model
                val wrapperElements = specElements.map { specElement ->
                    val file = specElement.containingFile
                    val displayText = "${file.name} (${specElement.text.take(50)}${if (specElement.text.length > 50) "..." else ""})"
                    PsiElementWrapper(specElement, displayText)
                }

                // If there are multiple spec elements, show a popup list
                val popup = JBPopupFactory.getInstance()
                    .createPopupChooserBuilder(wrapperElements)
                    .setTitle("Choose OpenAPI Specification")
                    .setItemChosenCallback { wrapper ->
                        PsiNavigateUtil.navigate(wrapper.element)
                    }
                    .setRenderer(object : ColoredListCellRenderer<PsiElementWrapper>() {
                        override fun customizeCellRenderer(
                            list: JList<out PsiElementWrapper>,
                            value: PsiElementWrapper,
                            index: Int,
                            selected: Boolean,
                            hasFocus: Boolean
                        ) {
                            append(value.displayText)
                        }
                    })
                    .createPopup()

                popup.showInBestPositionFor(element.findExistingEditor() ?: return@GutterIconNavigationHandler)
            }
        }
        navigationHandler.navigate(null, element)
    }

    /**
     * Checks if a class is generated by OpenAPI Generator by looking for:
     * 1. "OpenAPI Generator" comment in the file
     * 2. Specific annotations that indicate generated code
     * 3. Package naming patterns
     */
    private fun isOpenApiGeneratedClass(psiClass: PsiClass): Boolean {
        val containingFile = psiClass.containingFile

        // Check for "OpenAPI Generator" comment in the file
        val fileText = containingFile.text
        if (fileText.contains("OpenAPI Generator", ignoreCase = true)) {
            return true
        }

        // Check for common OpenAPI Generator annotations
        return psiClass.hasAnnotation("io.swagger.v3.oas.annotations.tags.Tag") ||
                psiClass.hasAnnotation("javax.annotation.Generated") ||
                psiClass.hasAnnotation("org.springframework.web.bind.annotation.RestController") ||
                isInGeneratedPackage(psiClass)
    }

    private fun isOpenApiGeneratedClass(ktClass: KtClass): Boolean {
        val containingFile = ktClass.containingFile

        // Check for "OpenAPI Generator" comment in the file
        val fileText = containingFile.text
        if (fileText.contains("OpenAPI Generator", ignoreCase = true)) {
            return true
        }

        // For Kotlin classes, we can also check annotations
        return ktClass.annotationEntries.any { annotation ->
            val annotationName = annotation.shortName?.asString()
            annotationName == "Tag" ||
                    annotationName == "Generated" ||
                    annotationName == "RestController"
        } || isInGeneratedPackage(ktClass)
    }

    private fun isOpenApiGeneratedTypeScript(element: PsiElement): Boolean {
        val containingFile = element.containingFile

        // Check for "OpenAPI Generator" comment in the file
        val fileText = containingFile.text
        return fileText.contains("OpenAPI Generator", ignoreCase = true)
    }

    /**
     * Checks if the class is in a package that typically contains generated code
     */
    private fun isInGeneratedPackage(psiClass: PsiClass): Boolean {
        val qualifiedName = psiClass.qualifiedName ?: return false
        return qualifiedName.contains(".api.") ||
                qualifiedName.contains(".controller.") ||
                qualifiedName.contains(".model.") ||
                qualifiedName.contains(".generated.")
    }

    private fun isInGeneratedPackage(ktClass: KtClass): Boolean {
        val fqName = ktClass.fqName?.asString() ?: return false
        return fqName.contains(".api.") ||
                fqName.contains(".controller.") ||
                fqName.contains(".model.") ||
                fqName.contains(".generated.")
    }

    /**
     * Checks if a method has OpenAPI operation indicators
     */
    private fun hasOpenApiOperation(psiMethod: PsiMethod): Boolean {
        return psiMethod.hasAnnotation("io.swagger.v3.oas.annotations.Operation") ||
                hasSpringMappingAnnotation(psiMethod)
    }

    private fun hasOpenApiOperation(ktFunction: KtNamedFunction): Boolean {
        return ktFunction.annotationEntries.any { annotation ->
            val annotationName = annotation.shortName?.asString()
            annotationName == "Operation" ||
                    isSpringMappingAnnotation(annotationName)
        }
    }

    private fun hasSpringMappingAnnotation(psiMethod: PsiMethod): Boolean {
        val springMappingAnnotations = listOf(
            "org.springframework.web.bind.annotation.GetMapping",
            "org.springframework.web.bind.annotation.PostMapping",
            "org.springframework.web.bind.annotation.PutMapping",
            "org.springframework.web.bind.annotation.DeleteMapping",
            "org.springframework.web.bind.annotation.PatchMapping",
            "org.springframework.web.bind.annotation.RequestMapping"
        )

        return springMappingAnnotations.any { psiMethod.hasAnnotation(it) }
    }

    private fun isSpringMappingAnnotation(annotationName: String?): Boolean {
        val springMappingNames = listOf(
            "GetMapping", "PostMapping", "PutMapping",
            "DeleteMapping", "PatchMapping", "RequestMapping"
        )

        return springMappingNames.contains(annotationName)
    }

    /**
     * Checks if a method is a valid delegate method that should have a line marker.
     * Valid delegate methods are:
     * - In a class ending with "Delegate"
     * - Not the "getRequest" method (which is infrastructure)
     * - Public methods (typically the API operations)
     */
    private fun isValidDelegateMethod(psiMethod: PsiMethod, containingClass: PsiClass): Boolean {
        val className = containingClass.name ?: return false
        if (!className.endsWith("Delegate")) return false

        // Exclude infrastructure methods
        if (psiMethod.name == "getRequest") return false

        // Only include public methods
        return psiMethod.hasModifierProperty(com.intellij.psi.PsiModifier.PUBLIC)
    }

    private fun isValidDelegateMethod(ktFunction: KtNamedFunction, containingClass: KtClass): Boolean {
        val className = containingClass.name ?: return false
        if (!className.endsWith("Delegate")) return false

        // Exclude infrastructure methods
        if (ktFunction.name == "getRequest") return false

        // Only include public methods (default in Kotlin)
        return !ktFunction.hasModifier(org.jetbrains.kotlin.lexer.KtTokens.PRIVATE_KEYWORD)
    }
}