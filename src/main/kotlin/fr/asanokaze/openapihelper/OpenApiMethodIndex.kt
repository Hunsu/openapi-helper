package fr.asanokaze.openapihelper

import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.project.ProjectManager
import com.intellij.openapi.roots.ProjectFileIndex
import com.intellij.psi.JavaPsiFacade
import com.intellij.psi.PsiMethod
import com.intellij.psi.search.GlobalSearchScope
import com.intellij.util.indexing.*
import com.intellij.util.io.DataExternalizer
import com.intellij.util.io.EnumeratorStringDescriptor
import com.intellij.util.io.KeyDescriptor
import java.io.DataInput
import java.io.DataOutput

private val LOG = Logger.getInstance(OpenApiMethodIndex::class.java)

class OpenApiMethodIndex : FileBasedIndexExtension<String, String>() {
    companion object {
        val KEY = ID.create<String, String>("fr.asanokaze.openapihelper.method")
    }

    override fun getName() = KEY

    override fun getVersion() = 18

    override fun dependsOnFileContent() = true

    override fun getIndexer(): DataIndexer<String, String, FileContent> = DataIndexer { fileContent ->
        val result = mutableMapOf<String, String>()

        if (fileContent.file.url.startsWith("jar")) return@DataIndexer result

        val text = fileContent.contentAsText

        // Handle Java and Kotlin files containing @Operation
        if ((fileContent.file.extension == "java" || fileContent.file.extension == "kt") &&
                text.contains("@Operation") &&
                text.contains("io.swagger.v3.oas.annotations")
        ) {
            val regex = Regex("""operationId\s*=\s*"([^"]+)"""")
            for (match in regex.findAll(text)) {
                val operationId = match.groups[1]?.value
                if (operationId != null) {
                    result[operationId] = fileContent.file.url
                }
            }
        }

        // Handle TypeScript files with "async XXXXXRaw("
        if (fileContent.file.extension == "ts" && text.contains("generated by Openapi Generator")) {
            val regex = Regex("""async (\w+)Raw\(""")
            for (match in regex.findAll(text)) {
                val rawFunctionName = match.groups[1]?.value
                if (rawFunctionName != null) {
                    val functionKey = rawFunctionName.removeSuffix("Raw")
                    result[functionKey] = fileContent.file.url
                }
            }
        }

        result
    }

    override fun getKeyDescriptor(): KeyDescriptor<String> = EnumeratorStringDescriptor.INSTANCE

    override fun getValueExternalizer(): EnumeratorStringDescriptor = EnumeratorStringDescriptor.INSTANCE

    override fun getInputFilter(): FileBasedIndex.InputFilter = FileBasedIndex.InputFilter { file ->
        val projectFileIndex = ProjectFileIndex.getInstance(ProjectManager.getInstance().openProjects.first())
        !projectFileIndex.isInLibrary(file) && !file.path.contains("node_modules") &&
                (file.extension == "java" || file.extension == "kt" || file.extension == "ts")
    }
}

private class PsiMethodExternalizer : DataExternalizer<PsiMethod> {
    override fun save(out: DataOutput, value: PsiMethod) {
        out.writeUTF(value.containingClass?.qualifiedName ?: "")
        out.writeUTF(value.name)
    }

    override fun read(input: DataInput): PsiMethod? {
        val className = input.readUTF()
        val methodName = input.readUTF()

        val project = ProjectManager.getInstance().openProjects.firstOrNull() ?: return null
        val psiClass = JavaPsiFacade.getInstance(project)
                .findClass(className, GlobalSearchScope.allScope(project))
                ?: return null

        return psiClass.findMethodsByName(methodName, false).firstOrNull()
    }
}